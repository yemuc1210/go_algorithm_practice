# 解析
首先，对于这一类问题，一般来说使用左开右闭区间[L,R)[L,R)是更优的。因此，我们在离散化时间戳时，将所有区间都按照[L,R)[L,R)的方式来进行处理。

显然，我们应当尽可能晚地执行任务，因为这样的话，当次执行有可能服务于更多的区间。

这里我们引入【槽位】的概念。所谓【槽位】，指的是一个任务当前能够空闲的最大时长。比如一个[1,6)[1,6)的任务，需要投入2的时长，那么它就有3个槽位，因为我们可以在[4,6)[4,6)进行执行，从而空出[1,4)[1,4)。

在离散化之后，我们逐段进行处理。显然，在考虑一段区间时，我们应当以当前剩余槽位最少的任务为准来进行安排。如果当前剩余槽位最少的为1个槽位，那么这个区间的开头最多空出1个位置，而后面的位置都得执行任务。

首先，我们将结束时间在当前时间之前的任务出队。
我们将当前时刻开始的任务入队。这里，我们在计算出该任务的槽位后，需要加上一个修正项extra，后面会说到。
我们考虑当前槽位最少的那个任务。以它为准进行任务执行之后，如果当前区间空了kk个位置，那么当前队列中的所有任务的剩余槽位都会减少kk。显然我们无法对队列中的每个元素进行操作。但我们可以反其道而行之，给之后入队的元素加上k。这里，我们把之后入队的元素需要累加的修正量记录在变量extra中。
时间复杂度\mathcal{O}(M\log M+N\log N)O(MlogM+NlogN)，其中MM是不同的时间戳的数目，NN是任务的数目

